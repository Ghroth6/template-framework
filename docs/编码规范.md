# TFW 编码规范

## 1. 总体原则

### 1.1 代码质量要求
- 代码应该简洁、清晰、可维护
- 优先考虑代码的可读性和可理解性
- 遵循一致的命名约定和格式规范
- 适当添加注释，特别是复杂逻辑部分

### 1.2 兼容性要求
- C接口必须完全兼容C89/C99标准
- C++代码建议使用C++11及以上标准
- 跨平台兼容（Windows、Linux、macOS）
- 支持多种编译器（GCC、Clang、MSVC）

## 2. 命名规范

### 2.1 文件命名
- 头文件：`TFW_模块名.h`
- 源文件：`TFW_模块名.c` 或 `TFW_模块名.cpp`
- 示例：`TFW_core.h`、`TFW_core.cpp`

### 2.2 函数命名

#### C接口函数
```c
// 格式：TFW_函数名（大驼峰）
TFW_Result TFW_CoreInit();
TFW_Result TFW_CoreDeinit();
TFW_Result TFW_UtilLogInit();
```

#### C++类方法
```cpp
// 格式：PascalCase（首字母大写的驼峰命名）
class CoreInterface {
public:
    static CoreInterface* GetInstance();
    TFW_Result Initialize();
    TFW_Result ExecuteOperation(const std::string& operation);
};
```

#### 内部函数
```c
// 格式：PascalCase（首字母大写的驼峰命名）
static int FormatLogMessage(char* buffer, size_t size, const char* format, ...);
static void CleanupResources();
```

### 2.3 变量命名

#### 全局变量/静态变量
```c
// 格式：g_变量名 或 s_变量名(小驼峰pascalCase)
static bool g_isInitialized = false;
static CoreInterface* s_instance = nullptr;
```

#### 局部变量
```c
// 格式：小驼峰pascalCase
int errorCode = 0;
char* bufferPtr = nullptr;
size_t bufferSize = 1024;
```

#### 成员变量
```cpp
// 格式：小驼峰pascalCase_ （下划线后缀）
class Core {
private:
    bool isInitialized_;
    TFW_Type mainType_;
    std::string operationName_;
};
```

### 2.4 常量和宏命名

#### 宏定义
```c
// 格式：TFW_模块_功能_具体名称（全大写，下划线分隔）
#define TFW_LOG_BUFFER_SIZE 1024
#define TFW_CORE_MAX_RETRY_COUNT 3
#define TFW_UTILS_VERSION_MAJOR 1
```

#### 枚举常量
```c
// 格式：TFW_枚举类型_具体值
typedef enum {
    TFW_LOG_LEVEL_TRACE = 0,
    TFW_LOG_LEVEL_DEBUG = 1,
    TFW_LOG_LEVEL_INFO = 2,
    TFW_LOG_LEVEL_WARNING = 3,
    TFW_LOG_LEVEL_ERROR = 4,
    TFW_LOG_LEVEL_FATAL = 5
} TFW_LogLevel;
```

### 2.5 类型定义
```c
// 格式：TFW_类型名
typedef enum TFW_ErrorCode TFW_ErrorCode;
typedef int32_t TFW_Result;
typedef struct TFW_LogContext TFW_LogContext;
```

## 3. 代码格式

### 3.1 缩进和空格
- 使用4个空格进行缩进，不使用Tab
- 运算符前后添加空格
- 逗号后添加空格
- 函数调用的括号内侧不加空格

```c
// 正确示例
int result = CalculateValue(param1, param2, param3);
if (result > 0) {
    ProcessResult(result);
}

// 错误示例
int result=CalculateValue( param1,param2,param3 );
if(result>0){
ProcessResult(result);
}
```

### 3.2 大括号风格
- 使用K&R风格（首大括号与入口在同一行）
- 除非为单块的独立括号分隔作用域，否则首大括号应与入口在同一行
- 即使只有一行代码，也要使用大括号

```c
// 正确示例
if (condition) {
    DoSomething();
} else {
    DoSomethingElse();
}

// 函数定义
int FunctionName(int param) {
    return param * 2;
}

// 单块独立括号分隔作用域示例
int ComplexFunction(int param) {
    if (param > 0) {
        // 处理正数
        return param * 2;
    }

    // 独立的作用域块
    {
        int temp = param * -1;
        return temp + 10;
    }
}
```

### 3.3 行长度
- 每行代码不超过120个字符
- 长的函数调用或表达式需要换行
- 换行时注意对齐，新行增加缩进以便于阅读
- 换行时以单词为标准，不截断单词
- 换行处存在运算符时，以运算符结尾并且不带空格
- 非必要时不换行

```c
// 短函数调用示例（无需换行）
result = ShortFunction(a, b, c);

// 需要换行的长函数调用示例
result = VeryLongFunctionNameWithManyParameters(parameter1, parameter2, parameter3, parameter4, parameter5,
    parameter6, parameter7, parameter8, parameter9, parameter10);

// 短条件表达式示例（无需换行）
if (ShortCheck() && AnotherCheck()) {
    // 处理逻辑
}

// 需要换行的长条件表达式示例
if (VeryLongConditionCheck() && AnotherLongConditionCheck() &&
    ThirdLongConditionCheck() && FourthLongConditionCheck()) {
    // 处理逻辑
}

// 短赋值语句示例（无需换行）
int short_var = SimpleCalculation(a, b);

// 需要换行的长赋值语句示例
int very_long_variable_name =
    CalculateComplexValue(parameter1, parameter2, parameter3, parameter4) +
    AnotherCalculation(parameter5, parameter6, parameter7, parameter8);

// 短函数定义示例（无需换行）
int ShortFunction(int a, int b) {
    return a + b;
}

// 需要换行的长函数定义参数示例
int ComplexFunctionWithManyParameters(int first_parameter, char* second_parameter,
    double third_parameter, bool fourth_parameter, long long fifth_parameter) {

    // 函数体
    return 0;
}
```

## 4. 注释规范

### 4.1 文件头注释
```c
/**
 * @file TFW_core.h
 * @brief TFW框架核心模块定义
 * @author 开发者姓名
 * @date 创建日期
 * @version 1.0.0
 *
 * 详细描述文件的功能和用途
 */
```

### 4.2 函数注释
```c
/**
 * @brief 初始化核心模块
 * @param[in] config 配置参数指针，可以为NULL使用默认配置
 * @param[out] handle 返回的句柄指针
 * @return TFW_Result 返回操作结果
 * @retval TFW_SUCCESS 初始化成功
 * @retval TFW_ERROR_INVALID_PARAM 参数无效
 * @retval TFW_ERROR_ALREADY_INITIALIZED 已经初始化
 *
 * @note 该函数只能调用一次，重复调用将返回错误
 * @warning 在多线程环境中使用时需要外部同步
 */
TFW_Result TFW_CoreInitialize(const TFW_Config* config, TFW_Handle* handle);
```

### 4.3 行内注释
```c
int buffer_size = 1024;     // 缓冲区大小，足够存储日志消息
bool is_valid = false;      // 标记数据是否有效

// 复杂逻辑前的解释注释
// 这里使用双重检查锁定模式确保线程安全的单例初始化
if (instance == nullptr) {
    lock_mutex();
    if (instance == nullptr) {
        instance = create_instance();
    }
    unlock_mutex();
}
```

## 5. 错误处理

### 5.1 返回值检查
```c
// 总是检查函数返回值
TFW_Result result = TFW_CoreInit();
if (result != TFW_SUCCESS) {
    TFW_LOGE_CORE("初始化失败: %d", result);
    return result;
}
```

### 5.2 错误码使用
```c
// 使用统一的错误码
return TFW_ERROR_INVALID_PARAM;  // 而不是返回 -1 或其他魔法数字

// 错误传播
TFW_Result internalResult = InitFunc();
if (internalResult != TFW_SUCCESS) {
    return internalResult;  // 直接传播错误码
}
```

### 5.3 资源清理
```c
// 总是在错误路径中清理资源
char* buffer = malloc(size);
if (buffer == nullptr) {
    return TFW_ERROR_MEMORY_ALLOCATION;
}

FILE* file = fopen(filename, "r");
if (file == nullptr) {
    free(buffer);  // 清理已分配的资源
    return TFW_ERROR_FILE_OPEN;
}

// ... 使用资源 ...

// 正常路径清理
fclose(file);
free(buffer);
return TFW_SUCCESS;
```

## 6. 头文件规范

### 6.1 头文件保护
```c
#ifndef TFW_CORE_H
#define TFW_CORE_H

// 头文件内容

#endif // TFW_CORE_H
```

### 6.2 包含顺序
```c
// 1. 系统头文件
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 2. 第三方库头文件
#include <third_party_lib.h>

// 3. 项目头文件
#include "TFW_types.h"
#include "TFW_errorno.h"
```

### 6.3 C++兼容性
```c
#ifdef __cplusplus
extern "C" {
#endif

// C接口声明

#ifdef __cplusplus
}
#endif
```

### 6.4 头文件编译规范
包含时仅include文件名，不允许包含相对路径
编译配置需要实现满足该标准的配置

#### 正确的包含方式
```c
// 正确：仅包含文件名
#include "TFW_core.h"
#include "TFW_log.h"
#include "TFW_types.h"

// 错误：包含相对路径
#include "../core/TFW_core.h"        // 不允许
#include "../../interface/TFW_types.h" // 不允许
#include "./utils/TFW_log.h"          // 不允许
```

#### CMake编译配置示例
```cmake
# 设置头文件搜索路径
target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/interface
    ${CMAKE_CURRENT_SOURCE_DIR}/core/include
    ${CMAKE_CURRENT_SOURCE_DIR}/utils/include
)

# 或者使用更通用的方式
include_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}/interface
    ${CMAKE_CURRENT_SOURCE_DIR}/core/include
    ${CMAKE_CURRENT_SOURCE_DIR}/utils/include
)
```

#### 项目结构示例
```
project/
├── interface/
│   ├── TFW_types.h
│   └── TFW_errorno.h
├── core/
│   ├── include/
│   │   └── TFW_core.h
│   └── TFW_core.cpp
├── utils/
│   ├── include/
│   │   ├── TFW_log.h
│   │   └── TFW_thread.h
│   └── TFW_log.c
└── main.cpp
```

#### 在main.cpp中的包含方式
```cpp
// 正确的包含方式
#include "TFW_types.h"      // 自动搜索interface目录
#include "TFW_core.h"       // 自动搜索core/include目录
#include "TFW_log.h"        // 自动搜索utils/include目录

int main() {
    // 使用头文件中定义的类型和函数
    TFW_Result result = TFW_CoreInit();
    return 0;
}
```

## 7. 日志使用规范

### 7.1 日志等级选择
```c
TFW_LOGT_CORE("详细的调试追踪信息");           // 仅用于开发调试
TFW_LOGD_CORE("调试信息: 变量值 = %d", value);  // 开发和测试阶段
TFW_LOGI_CORE("操作完成: %s", operation);        // 重要的状态信息
TFW_LOGW_CORE("警告: 参数可能不合理 = %d", param); // 可能的问题
TFW_LOGE_CORE("错误: 操作失败 = %d", error_code);  // 错误信息
TFW_LOGF_CORE("致命错误: 系统无法继续运行");      // 系统级错误
```

### 7.2 日志格式
```c
// 包含足够的上下文信息
TFW_LOGI_CORE("用户登录成功: user_id=%d, session_id=%s",
              user_id, session_id);

// 错误日志包含错误码和描述
TFW_LOGE_CORE("文件操作失败: file=%s, error=%d, message=%s",
              filename, errno, strerror(errno));
```

## 8. 性能考虑

### 8.1 避免不必要的字符串操作
```c
// 推荐：使用常量字符串
const char* GetStatusString(int status) {
    switch (status) {
        case 0: return "Success";
        case 1: return "Error";
        default: return "Unknown";
    }
}

// 避免：每次都重新格式化字符串
```

### 8.2 内存管理
```c
// 尽量使用栈上分配
char buffer[256];  // 而不是 malloc/free

// 需要动态分配时，及时释放
char* buffer = malloc(size);
if (buffer != nullptr) {
    // 使用buffer
    free(buffer);
    buffer = nullptr;  // 避免野指针
}
```

## 9. 平台兼容性

### 9.1 默认代码为unix平台适配

#### 文件目录结构
```
utils/
├── thread/
│   ├── posix/
│   │   └── TFW_thread_impl.c    # 默认UNIX实现（Linux/macOS通用）
│   ├── win32/
│   │   └── TFW_thread_impl.c    # Windows平台特殊实现
│   └── macos/
│       └── TFW_thread_impl.c    # macOS平台特殊实现
├── timer/
│   ├── posix/
│   │   └── TFW_timer_impl.c     # 默认UNIX实现（Linux通用）
│   ├── win32/
│   │   └── TFW_timer_impl.c     # Windows平台特殊实现
│   └── macos/
│       └── TFW_timer_impl.c     # macOS平台特殊实现
├── file/
│   ├── posix/
│   │   └── TFW_file_impl.c      # 默认UNIX实现（Linux/macOS通用）
│   └── win32/
│       └── TFW_file_impl.c      # Windows平台特殊实现
└── mem/
    ├── posix/
    │   └── TFW_mem_impl.c       # 默认UNIX实现（Linux/macOS通用）
    └── win32/
        └── TFW_mem_impl.c       # Windows平台特殊实现
```

#### CMake编译控制示例
```cmake
# 根据平台选择平台特定实现
if(WIN32)
    # Windows平台实现
    list(APPEND UTILS_SOURCES
        thread/win32/TFW_thread_impl.c
        timer/win32/TFW_timer_impl.c
        file/win32/TFW_file_impl.c
        mem/win32/TFW_mem_impl.c
    )
elseif(APPLE)
    # macOS平台实现
    list(APPEND UTILS_SOURCES
        thread/posix/TFW_thread_impl.c
        timer/macos/TFW_timer_impl.c
        file/posix/TFW_file_impl.c
        mem/posix/TFW_mem_impl.c
    )
else()
    # Linux/Unix平台实现
    list(APPEND UTILS_SOURCES
        thread/posix/TFW_thread_impl.c
        timer/posix/TFW_timer_impl.c
        file/posix/TFW_file_impl.c
        mem/posix/TFW_mem_impl.c
    )
endif()
```

### 9.2 数据类型
```c
// 使用标准整数类型
#include <stdint.h>
uint32_t value;     // 而不是 unsigned int
int64_t timestamp;  // 而不是 long long
```

### 9.3 IDE配置
编译配置需尽量保持对IDE的兼容性，如为VSCode自动生成compile_commands.json文件

#### 头文件包含路径管理
现代CMake项目应遵循以下原则，实现类似GN构建系统的便捷包含体验：

```cmake
# 为库目标设置公开的头文件路径
add_library(tfw_core STATIC src/core.cpp)
target_include_directories(tfw_core
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/include  # 公共头文件目录，会传递给依赖者
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/src      # 私有头文件目录，不传递
)

# 在可执行文件中链接库，而不是手动添加路径
add_executable(my_app main.cpp)
target_link_libraries(my_app PRIVATE tfw_core)

# 避免使用旧式全局包含（容易冲突）
# include_directories(../include)  # ❌ 不推荐
```

#### VSCode配置最佳实践

**方法一：使用CMake Tools扩展（推荐）**
1. 安装扩展：`ms-vscode.cmake-tools`
2. 在项目根目录配置Kit（编译器）和Build Type
3. CMake Tools会自动生成`compile_commands.json`文件
4. C/C++插件自动识别路径，解决红色波浪线问题

**方法二：手动配置c_cpp_properties.json（备用）**
```json
{
    "configurations": [
        {
            "name": "Linux",
            "includePath": [
                "${workspaceFolder}/**",
                "${workspaceFolder}/interface",
                "${workspaceFolder}/core/include",
                "${workspaceFolder}/utils/include"
            ],
            "defines": [],
            "compilerPath": "/usr/bin/gcc",
            "cStandard": "c11",
            "cppStandard": "c++11",
            "intelliSenseMode": "linux-gcc-x64"
        }
    ],
    "version": 4
}
```

#### 项目结构示例
```
project/
├── CMakeLists.txt
├── compile_commands.json          # CMake Tools自动生成
├── interface/
│   ├── TFW_types.h
│   └── TFW_errorno.h
├── core/
│   ├── include/
│   │   └── TFW_core.h
│   └── src/
│       └── TFW_core.cpp
└── main.cpp
```

#### 在main.cpp中的使用
```cpp
// 正确的包含方式（无需相对路径）
#include "TFW_types.h"      // 自动搜索interface目录
#include "TFW_core.h"       // 自动搜索core/include目录

int main() {
    TFW_Result result = TFW_CoreInit();
    return 0;
}
```

#### 关键配置要点
- 使用`target_include_directories(target PUBLIC path)`设置公开头文件路径
- 通过`target_link_libraries`实现依赖传递
- 避免使用全局`include_directories`
- 优先使用CMake Tools扩展自动生成`compile_commands.json`

### 9.4 编译流程控制
编译生成的中间文件控制在独立的build目录下，最终生成的文件默认生成在out目录下，项目的主编译配置文件与入口位于根目录，并为不同的平台做一个建议的编译入口脚本

#### 目录结构规范
```
project_root/
├── CMakeLists.txt                 # 主编译配置文件
├── build/                         # 中间文件目录（可清理）
│   ├── CMakeCache.txt
│   ├── CMakeFiles/
│   ├── Makefile
│   └── compile_commands.json
├── out/                           # 最终输出目录
│   ├── bin/                       # 可执行文件
│   ├── lib/                       # 库文件
│   └── include/                   # 头文件（如需要分发）
├── build_simple.sh                # Linux/macOS编译脚本
├── build_simple.bat               # Windows编译脚本
└── build_simple.ps1               # Windows PowerShell脚本
```

#### 主CMakeLists.txt配置
```cmake
cmake_minimum_required(VERSION 3.16)
project(TFW VERSION 1.0.0 LANGUAGES C CXX)

# 设置输出目录
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/../out/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/../out/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/../out/lib)

# 设置中间文件目录
set(CMAKE_BINARY_DIR ${CMAKE_SOURCE_DIR}/build)

# 添加子目录
add_subdirectory(interface)
add_subdirectory(core)
add_subdirectory(utils)
add_subdirectory(simple)

# 生成compile_commands.json（用于IDE支持）
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
```

#### Linux/macOS编译脚本 (build_simple.sh)
```bash
#!/bin/bash

# 设置错误时退出
set -e

echo "开始构建TFW项目..."

# 创建构建目录
mkdir -p build
mkdir -p out/bin
mkdir -p out/lib

# 进入构建目录
cd build

# 配置项目
echo "配置CMake项目..."
cmake .. -DCMAKE_BUILD_TYPE=Release

# 编译项目
echo "编译项目..."
make -j$(nproc)

echo "构建完成！"
echo "可执行文件位置: ../out/bin/"
echo "库文件位置: ../out/lib/"
```

#### Windows批处理脚本 (build_simple.bat)
```batch
@echo off
setlocal enabledelayedexpansion

echo 开始构建TFW项目...

REM 创建构建目录
if not exist build mkdir build
if not exist out\bin mkdir out\bin
if not exist out\lib mkdir out\lib

REM 进入构建目录
cd build

REM 配置项目
echo 配置CMake项目...
cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release

REM 编译项目
echo 编译项目...
cmake --build . --config Release

echo 构建完成！
echo 可执行文件位置: ..\out\bin\
echo 库文件位置: ..\out\lib\

pause
```

#### Windows PowerShell脚本 (build_simple.ps1)
```powershell
# 设置错误时退出
$ErrorActionPreference = "Stop"

Write-Host "开始构建TFW项目..." -ForegroundColor Green

# 创建构建目录
if (!(Test-Path "build")) { New-Item -ItemType Directory -Path "build" }
if (!(Test-Path "out\bin")) { New-Item -ItemType Directory -Path "out\bin" }
if (!(Test-Path "out\lib")) { New-Item -ItemType Directory -Path "out\lib" }

# 进入构建目录
Set-Location build

# 配置项目
Write-Host "配置CMake项目..." -ForegroundColor Yellow
cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release

# 编译项目
Write-Host "编译项目..." -ForegroundColor Yellow
cmake --build . --config Release

Write-Host "构建完成！" -ForegroundColor Green
Write-Host "可执行文件位置: ..\out\bin\" -ForegroundColor Cyan
Write-Host "库文件位置: ..\out\lib\" -ForegroundColor Cyan

# 返回根目录
Set-Location ..
```

#### 清理脚本

**Linux/macOS清理脚本 (clean.sh)**
```bash
#!/bin/bash
# clean.sh - 清理构建文件

echo "清理构建文件..."

# 删除build目录
if [ -d "build" ]; then
    rm -rf build
    echo "已删除build目录"
fi

# 删除out目录
if [ -d "out" ]; then
    rm -rf out
    echo "已删除out目录"
fi

echo "清理完成！"
```

**Windows批处理清理脚本 (clean.bat)**
```batch
@echo off
echo 清理构建文件...

REM 删除build目录
if exist build (
    rmdir /s /q build
    echo 已删除build目录
)

REM 删除out目录
if exist out (
    rmdir /s /q out
    echo 已删除out目录
)

echo 清理完成！
pause
```

**Windows PowerShell清理脚本 (clean.ps1)**
```powershell
Write-Host "清理构建文件..." -ForegroundColor Yellow

# 删除build目录
if (Test-Path "build") {
    Remove-Item -Path "build" -Recurse -Force
    Write-Host "已删除build目录" -ForegroundColor Green
}

# 删除out目录
if (Test-Path "out") {
    Remove-Item -Path "out" -Recurse -Force
    Write-Host "已删除out目录" -ForegroundColor Green
}

Write-Host "清理完成！" -ForegroundColor Green
```

#### 关键配置要点
- **输出目录分离**：中间文件在`build/`，最终文件在`out/`
- **平台特定脚本**：为不同平台提供便捷的编译入口
- **CMake配置**：主配置文件位于根目录，统一管理所有模块
- **IDE支持**：自动生成`compile_commands.json`文件
- **清理机制**：提供清理脚本，便于重新构建

## 10. 代码审查检查点

### 10.1 命名规范检查
- [ ] C接口函数是否使用 `TFW_函数名（大驼峰）` 格式
- [ ] C++类方法是否使用 `PascalCase` 格式
- [ ] 内部函数是否使用 `PascalCase` 格式
- [ ] 变量是否使用 `camelCase` 格式
- [ ] 全局/静态变量是否使用 `g_变量名` 或 `s_变量名` 格式
- [ ] 宏定义是否使用 `TFW_模块_功能_具体名称` 格式
- [ ] 枚举常量是否使用 `TFW_枚举类型_具体值` 格式

### 10.2 代码格式检查
- [ ] 是否使用4个空格缩进（不使用Tab）
- [ ] 大括号是否使用K&R风格（首大括号与入口在同一行）
- [ ] 行长度是否控制在120字符以内
- [ ] 运算符前后是否添加空格
- [ ] 逗号后是否添加空格
- [ ] 换行时是否保持适当缩进和对齐

### 10.3 注释规范检查
- [ ] 文件头是否有完整的Doxygen注释（@file, @brief, @author, @date, @version）
- [ ] 函数是否有详细的参数说明（@param[in/out], @return, @retval）
- [ ] 复杂逻辑前是否有解释注释
- [ ] 行内注释是否简洁明了
- [ ] 是否有@note和@warning等特殊说明

### 10.4 错误处理检查
- [ ] 是否总是检查函数返回值
- [ ] 是否使用统一的错误码（TFW_ERROR_*）
- [ ] 错误路径中是否正确清理资源
- [ ] 是否避免使用魔法数字（-1, 0xFFFF等）
- [ ] 错误传播是否正确

### 10.5 资源管理检查
- [ ] 动态分配的内存是否及时释放
- [ ] 文件句柄是否正确关闭
- [ ] 锁是否在正确位置释放
- [ ] 是否避免野指针（释放后置nullptr）
- [ ] 是否优先使用栈上分配

### 10.6 平台兼容性检查
- [ ] 默认代码是否为UNIX平台适配
- [ ] 平台特定实现是否放在对应目录（posix/, win32/, macos/）
- [ ] 条件编译是否正确（#ifdef _WIN32, #ifdef __APPLE__）
- [ ] CMake是否根据平台选择正确的源文件
- [ ] 是否包含必要的平台特定头文件

### 10.7 性能和安全检查
- [ ] 是否避免不必要的字符串操作
- [ ] 是否使用常量字符串而非重复格式化
- [ ] 线程安全性是否考虑
- [ ] 边界条件是否正确处理
- [ ] 空指针是否检查

### 10.8 日志使用检查
- [ ] 是否选择合适的日志等级
- [ ] 日志消息是否包含足够的上下文信息
- [ ] 是否使用模块专用的日志宏（TFW_LOGI_CORE等）
- [ ] 错误日志是否包含错误码和描述

### 10.9 头文件包含检查
- [ ] 是否仅包含文件名（不包含相对路径）
- [ ] 是否通过CMake配置实现头文件路径管理
- [ ] 是否使用`target_include_directories`设置公开头文件路径
- [ ] 是否通过`target_link_libraries`实现依赖传递
- [ ] 是否避免使用全局`include_directories`

### 10.10 IDE兼容性检查
- [ ] 是否生成`compile_commands.json`文件
- [ ] VSCode配置是否正确（CMake Tools或手动配置）
- [ ] 头文件智能提示是否正常工作
- [ ] 是否避免使用相对路径包含头文件
- [ ] 项目结构是否符合现代CMake最佳实践

### 10.11 平台适配检查
- [ ] 默认代码是否为UNIX平台适配
- [ ] 平台特定实现是否放在对应目录（posix/, win32/, macos/）
- [ ] 条件编译是否正确（#ifdef _WIN32, #ifdef __APPLE__）
- [ ] CMake是否根据平台选择正确的源文件
- [ ] 是否包含必要的平台特定头文件
- [ ] 平台特定代码是否与默认实现保持接口一致

---

## 11. 代码审查流程与范围

### 11.1 审查范围
代码审查应覆盖以下所有方面：
- **代码质量**：命名规范、格式一致性、注释完整性
- **功能正确性**：逻辑正确性、边界条件处理、错误处理
- **安全性**：资源管理、空指针检查、线程安全
- **性能**：算法效率、内存使用、字符串操作
- **可维护性**：代码结构、模块化设计、依赖管理
- **兼容性**：跨平台支持、编译器兼容、IDE支持

### 11.2 审查流程
1. **提交前自检**：开发者使用检查点进行自我审查
2. **同行评审**：至少一名团队成员进行代码审查
3. **自动化检查**：使用工具检查格式、命名等基础规范
4. **集成测试**：确保修改不影响现有功能
5. **最终审核**：项目负责人或技术负责人进行最终确认

### 11.3 审查工具推荐
- **代码格式检查**：clang-format, clang-tidy
- **静态分析**：Cppcheck, SonarQube
- **构建验证**：CMake, Ninja
- **IDE集成**：VSCode + CMake Tools, CLion

### 11.4 审查重点
- **新增功能**：重点关注接口设计、错误处理、资源管理
- **重构代码**：确保不破坏现有功能和接口
- **平台适配**：验证跨平台兼容性和平台特定实现
- **性能优化**：确保优化不引入新的问题
- **安全修复**：验证修复的完整性和影响范围

---

本规范将随着项目发展持续更新和完善。