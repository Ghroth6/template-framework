# TFW 编码规范

## 1. 总体原则

### 1.1 代码质量要求
- 代码应该简洁、清晰、可维护
- 优先考虑代码的可读性和可理解性
- 遵循一致的命名约定和格式规范
- 适当添加注释，特别是复杂逻辑部分

### 1.2 兼容性要求
- C接口必须完全兼容C89/C99标准
- C++代码建议使用C++11及以上标准
- 跨平台兼容（Windows、Linux、macOS）
- 支持多种编译器（GCC、Clang、MSVC）

## 2. 命名规范

### 2.1 文件命名
- 头文件：`TFW_模块名.h`
- 源文件：`TFW_模块名.c` 或 `TFW_模块名.cpp`
- 示例：`TFW_core.h`、`TFW_core.cpp`

### 2.2 函数命名

#### C接口函数
```c
// 格式：TFW_函数名（大驼峰）
TFW_Result TFW_CoreInit();
TFW_Result TFW_CoreDeinit();
TFW_Result TFW_UtilLogInit();
```

#### C++类方法
```cpp
// 格式：PascalCase（首字母大写的驼峰命名）
class CoreInterface {
public:
    static CoreInterface* GetInstance();
    TFW_Result Initialize();
    TFW_Result ExecuteOperation(const std::string& operation);
};
```

#### 内部函数
```c
// 格式：PascalCase（首字母大写的驼峰命名）
static int FormatLogMessage(char* buffer, size_t size, const char* format, ...);
static void CleanupResources();
```

### 2.3 变量命名

#### 全局变量/静态变量
```c
// 格式：g_变量名 或 s_变量名(小驼峰pascalCase)
static bool g_isInitialized = false;
static CoreInterface* s_instance = nullptr;
```

#### 局部变量
```c
// 格式：小驼峰pascalCase
int errorCode = 0;
char* bufferPtr = nullptr;
size_t bufferSize = 1024;
```

#### 成员变量
```cpp
// 格式：小驼峰pascalCase_ （下划线后缀）
class Core {
private:
    bool isInitialized_;
    TFW_Type mainType_;
    std::string operationName_;
};
```

### 2.4 常量和宏命名

#### 宏定义
```c
// 格式：TFW_模块_功能_具体名称（全大写，下划线分隔）
#define TFW_LOG_BUFFER_SIZE 1024
#define TFW_CORE_MAX_RETRY_COUNT 3
#define TFW_UTILS_VERSION_MAJOR 1
```

#### 枚举常量
```c
// 格式：TFW_枚举类型_具体值
typedef enum {
    TFW_LOG_LEVEL_TRACE = 0,
    TFW_LOG_LEVEL_DEBUG = 1,
    TFW_LOG_LEVEL_INFO = 2,
    TFW_LOG_LEVEL_WARNING = 3,
    TFW_LOG_LEVEL_ERROR = 4,
    TFW_LOG_LEVEL_FATAL = 5
} TFW_LogLevel;
```

### 2.5 类型定义
```c
// 格式：TFW_类型名
typedef enum TFW_ErrorCode TFW_ErrorCode;
typedef int32_t TFW_Result;
typedef struct TFW_LogContext TFW_LogContext;
```

## 3. 代码格式

### 3.1 缩进和空格
- 使用4个空格进行缩进，不使用Tab
- 运算符前后添加空格
- 逗号后添加空格
- 函数调用的括号内侧不加空格

```c
// 正确示例
int result = CalculateValue(param1, param2, param3);
if (result > 0) {
    ProcessResult(result);
}

// 错误示例
int result=CalculateValue( param1,param2,param3 );
if(result>0){
ProcessResult(result);
}
```

### 3.2 大括号风格
- 使用K&R风格（首大括号与入口在同一行）
- 除非为单块的独立括号分隔作用域，否则首大括号应与入口在同一行
- 即使只有一行代码，也要使用大括号

```c
// 正确示例
if (condition) {
    DoSomething();
} else {
    DoSomethingElse();
}

// 函数定义
int FunctionName(int param) {
    return param * 2;
}

// 单块独立括号分隔作用域示例
int ComplexFunction(int param) {
    if (param > 0) {
        // 处理正数
        return param * 2;
    }

    // 独立的作用域块
    {
        int temp = param * -1;
        return temp + 10;
    }
}
```

### 3.3 行长度
- 每行代码不超过120个字符
- 长的函数调用或表达式需要换行
- 换行时注意对齐，新行增加缩进以便于阅读
- 换行时以单词为标准，不截断单词
- 换行处存在运算符时，以运算符结尾并且不带空格
- 非必要时不换行

```c
// 短函数调用示例（无需换行）
result = ShortFunction(a, b, c);

// 需要换行的长函数调用示例
result = VeryLongFunctionNameWithManyParameters(parameter1, parameter2, parameter3, parameter4, parameter5,
    parameter6, parameter7, parameter8, parameter9, parameter10);

// 短条件表达式示例（无需换行）
if (ShortCheck() && AnotherCheck()) {
    // 处理逻辑
}

// 需要换行的长条件表达式示例
if (VeryLongConditionCheck() && AnotherLongConditionCheck() &&
    ThirdLongConditionCheck() && FourthLongConditionCheck()) {
    // 处理逻辑
}

// 短赋值语句示例（无需换行）
int short_var = SimpleCalculation(a, b);

// 需要换行的长赋值语句示例
int very_long_variable_name =
    CalculateComplexValue(parameter1, parameter2, parameter3, parameter4) +
    AnotherCalculation(parameter5, parameter6, parameter7, parameter8);

// 短函数定义示例（无需换行）
int ShortFunction(int a, int b) {
    return a + b;
}

// 需要换行的长函数定义参数示例
int ComplexFunctionWithManyParameters(int first_parameter, char* second_parameter,
    double third_parameter, bool fourth_parameter, long long fifth_parameter) {

    // 函数体
    return 0;
}
```

## 4. 注释规范

### 4.1 文件头注释
```c
/**
 * @file TFW_core.h
 * @brief TFW框架核心模块定义
 * @author 开发者姓名
 * @date 创建日期
 * @version 1.0.0
 *
 * 详细描述文件的功能和用途
 */
```

### 4.2 函数注释
```c
/**
 * @brief 初始化核心模块
 * @param[in] config 配置参数指针，可以为NULL使用默认配置
 * @param[out] handle 返回的句柄指针
 * @return TFW_Result 返回操作结果
 * @retval TFW_SUCCESS 初始化成功
 * @retval TFW_ERROR_INVALID_PARAM 参数无效
 * @retval TFW_ERROR_ALREADY_INITIALIZED 已经初始化
 *
 * @note 该函数只能调用一次，重复调用将返回错误
 * @warning 在多线程环境中使用时需要外部同步
 */
TFW_Result TFW_CoreInitialize(const TFW_Config* config, TFW_Handle* handle);
```

### 4.3 行内注释
```c
int buffer_size = 1024;     // 缓冲区大小，足够存储日志消息
bool is_valid = false;      // 标记数据是否有效

// 复杂逻辑前的解释注释
// 这里使用双重检查锁定模式确保线程安全的单例初始化
if (instance == nullptr) {
    lock_mutex();
    if (instance == nullptr) {
        instance = create_instance();
    }
    unlock_mutex();
}
```

## 5. 错误处理

### 5.1 返回值检查
```c
// 总是检查函数返回值
TFW_Result result = TFW_CoreInit();
if (result != TFW_SUCCESS) {
    TFW_LOGE_CORE("初始化失败: %d", result);
    return result;
}
```

### 5.2 错误码使用
```c
// 使用统一的错误码
return TFW_ERROR_INVALID_PARAM;  // 而不是返回 -1 或其他魔法数字

// 错误传播
TFW_Result internalResult = InitFunc();
if (internalResult != TFW_SUCCESS) {
    return internalResult;  // 直接传播错误码
}
```

### 5.3 资源清理
```c
// 总是在错误路径中清理资源
char* buffer = malloc(size);
if (buffer == nullptr) {
    return TFW_ERROR_MEMORY_ALLOCATION;
}

FILE* file = fopen(filename, "r");
if (file == nullptr) {
    free(buffer);  // 清理已分配的资源
    return TFW_ERROR_FILE_OPEN;
}

// ... 使用资源 ...

// 正常路径清理
fclose(file);
free(buffer);
return TFW_SUCCESS;
```

## 6. 头文件规范

### 6.1 头文件保护
```c
#ifndef TFW_CORE_H
#define TFW_CORE_H

// 头文件内容

#endif // TFW_CORE_H
```

### 6.2 包含顺序
```c
// 1. 系统头文件
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 2. 第三方库头文件
#include <third_party_lib.h>

// 3. 项目头文件
#include "TFW_types.h"
#include "TFW_errorno.h"
```

### 6.3 C++兼容性
```c
#ifdef __cplusplus
extern "C" {
#endif

// C接口声明

#ifdef __cplusplus
}
#endif
```

### 6.4 头文件编译规范
包含时仅include文件名，不允许包含相对路径
编译配置需要实现满足该标准的配置

#### 正确的包含方式
```c
// 正确：仅包含文件名
#include "TFW_core.h"
#include "TFW_log.h"
#include "TFW_types.h"

// 错误：包含相对路径
#include "../core/TFW_core.h"        // 不允许
#include "../../interface/TFW_types.h" // 不允许
#include "./utils/TFW_log.h"          // 不允许
```

#### CMake编译配置示例
```cmake
# 设置头文件搜索路径
target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}/interface
    ${CMAKE_CURRENT_SOURCE_DIR}/core/include
    ${CMAKE_CURRENT_SOURCE_DIR}/utils/include
)

# 或者使用更通用的方式
include_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}/interface
    ${CMAKE_CURRENT_SOURCE_DIR}/core/include
    ${CMAKE_CURRENT_SOURCE_DIR}/utils/include
)
```

#### 项目结构示例
```
project/
├── interface/
│   ├── TFW_types.h
│   └── TFW_errorno.h
├── core/
│   ├── include/
│   │   └── TFW_core.h
│   └── TFW_core.cpp
├── utils/
│   ├── include/
│   │   ├── TFW_log.h
│   │   └── TFW_thread.h
│   └── TFW_log.c
└── main.cpp
```

#### 在main.cpp中的包含方式
```cpp
// 正确的包含方式
#include "TFW_types.h"      // 自动搜索interface目录
#include "TFW_core.h"       // 自动搜索core/include目录
#include "TFW_log.h"        // 自动搜索utils/include目录

int main() {
    // 使用头文件中定义的类型和函数
    TFW_Result result = TFW_CoreInit();
    return 0;
}
```

## 7. 日志使用规范

### 7.1 日志等级选择
```c
TFW_LOGT_CORE("详细的调试追踪信息");           // 仅用于开发调试
TFW_LOGD_CORE("调试信息: 变量值 = %d", value);  // 开发和测试阶段
TFW_LOGI_CORE("操作完成: %s", operation);        // 重要的状态信息
TFW_LOGW_CORE("警告: 参数可能不合理 = %d", param); // 可能的问题
TFW_LOGE_CORE("错误: 操作失败 = %d", error_code);  // 错误信息
TFW_LOGF_CORE("致命错误: 系统无法继续运行");      // 系统级错误
```

### 7.2 日志格式
```c
// 包含足够的上下文信息
TFW_LOGI_CORE("用户登录成功: user_id=%d, session_id=%s",
              user_id, session_id);

// 错误日志包含错误码和描述
TFW_LOGE_CORE("文件操作失败: file=%s, error=%d, message=%s",
              filename, errno, strerror(errno));
```

## 8. 性能考虑

### 8.1 避免不必要的字符串操作
```c
// 推荐：使用常量字符串
const char* GetStatusString(int status) {
    switch (status) {
        case 0: return "Success";
        case 1: return "Error";
        default: return "Unknown";
    }
}

// 避免：每次都重新格式化字符串
```

### 8.2 内存管理
```c
// 尽量使用栈上分配
char buffer[256];  // 而不是 malloc/free

// 需要动态分配时，及时释放
char* buffer = malloc(size);
if (buffer != nullptr) {
    // 使用buffer
    free(buffer);
    buffer = nullptr;  // 避免野指针
}
```

## 8.3 内存安全设计原则

### 8.3.1 避免返回指针的设计
**禁止返回指向可能无效内存的指针，特别是字符串指针**

```c
// ❌ 错误设计：返回指针容易引起内存安全问题
const char* GetConfigValue(int key);
const char* GetFileName(const char* path);

// ✅ 正确设计：使用入参出参模式
int32_t GetConfigValue(int key, char* value, size_t buffer_size);
int32_t GetFileName(const char* path, char* filename, size_t buffer_size);
```

### 8.3.2 统一的字符串处理模式
**所有涉及字符串返回的函数都应使用缓冲区传递模式**

```c
// 标准模式：返回状态码，通过参数输出结果
int32_t TFW_Config_GetValueByKey(TFW_ConfigKey key, char* value, size_t buffer_size);
int32_t TFW_File_GetFileName(const char* path, char* filename, size_t buffer_size);
int32_t TFW_Log_GetFileName(const char* path, char* filename, size_t buffer_size);

// 使用示例
char config_value[256];
int32_t ret = TFW_Config_GetValueByKey(TFW_CONFIG_MAIN_VERSION, config_value, sizeof(config_value));
if (ret == TFW_SUCCESS) {
    // 使用 config_value
    printf("Version: %s\n", config_value);
} else {
    // 处理错误
    printf("Failed to get config value: %d\n", ret);
}
```

### 8.3.3 缓冲区安全设计
**所有缓冲区操作都必须进行边界检查**

```c
// ✅ 正确的缓冲区操作
int32_t SafeStringCopy(char* dest, size_t dest_size, const char* src) {
    if (dest == NULL || src == NULL || dest_size == 0) {
        return TFW_ERROR_INVALID_PARAM;
    }

    size_t src_len = strlen(src);
    if (src_len >= dest_size) {
        return TFW_ERROR;  // 缓冲区太小
    }

    strcpy(dest, src);
    return TFW_SUCCESS;
}

// ❌ 错误的缓冲区操作
void UnsafeStringCopy(char* dest, const char* src) {
    strcpy(dest, src);  // 没有边界检查，可能导致缓冲区溢出
}
```

### 8.3.4 内存生命周期管理
**明确内存的所有权和生命周期**

```c
// ✅ 明确的内存所有权：调用者负责分配和释放
int32_t ProcessData(const char* input, char* output, size_t output_size) {
    // 函数不分配内存，调用者负责提供缓冲区
    if (output == NULL || output_size == 0) {
        return TFW_ERROR_INVALID_PARAM;
    }

    // 处理逻辑...
    strncpy(output, processed_data, output_size - 1);
    output[output_size - 1] = '\0';

    return TFW_SUCCESS;
}

// 使用示例
char result[1024];
int32_t ret = ProcessData(input_data, result, sizeof(result));
if (ret == TFW_SUCCESS) {
    // 使用 result，无需释放
    printf("Result: %s\n", result);
}
```

### 8.3.5 错误处理与内存安全
**错误情况下必须正确清理已分配的资源**

```c
// ✅ 正确的错误处理
int32_t AllocateAndProcess(char** result, size_t* result_size) {
    char* buffer = malloc(1024);
    if (buffer == NULL) {
        return TFW_ERROR_MEMORY_ALLOCATION;
    }

    // 处理逻辑
    int32_t process_ret = ProcessBuffer(buffer, 1024);
    if (process_ret != TFW_SUCCESS) {
        free(buffer);  // 错误时清理资源
        return process_ret;
    }

    *result = buffer;
    *result_size = 1024;
    return TFW_SUCCESS;
}
```

### 8.3.6 静态缓冲区使用原则
**避免使用静态缓冲区，优先使用调用者提供的缓冲区**

```c
// ❌ 错误设计：静态缓冲区存在线程安全问题
const char* GetConfigName(int key) {
    static char name[256];  // 线程不安全
    // ...
    return name;
}

// ✅ 正确设计：调用者提供缓冲区
int32_t GetConfigName(int key, char* name, size_t buffer_size) {
    if (name == NULL || buffer_size == 0) {
        return TFW_ERROR_INVALID_PARAM;
    }
    // ...
    return TFW_SUCCESS;
}
```

### 8.3.7 无效值处理原则
**对于可能无效的输入，必须返回明确的无效值，而不是看似可用但实际不保证可用性的值**

```c
// ❌ 错误设计：对无效输入返回看似可用的默认值
TFW_ConfigValueType GetKeyType(TFW_ConfigKey key) {
    switch (key) {
        case TFW_CONFIG_MAIN_VERSION:
            return TFW_CONFIG_TYPE_STRING;
        // ... 其他有效key
        default:
            return TFW_CONFIG_TYPE_STRING;  // 错误：无效key返回有效类型
    }
}

// ✅ 正确设计：对无效输入返回明确的无效值
typedef enum {
    TFW_CONFIG_TYPE_STRING = 0,
    TFW_CONFIG_TYPE_INT,
    TFW_CONFIG_TYPE_BOOL,
    TFW_CONFIG_TYPE_FLOAT,
    TFW_CONFIG_TYPE_INVALID  // 明确的无效类型
} TFW_ConfigValueType;

TFW_ConfigValueType GetKeyType(TFW_ConfigKey key) {
    switch (key) {
        case TFW_CONFIG_MAIN_VERSION:
            return TFW_CONFIG_TYPE_STRING;
        // ... 其他有效key
        default:
            return TFW_CONFIG_TYPE_INVALID;  // 正确：无效key返回无效类型
    }
}
```

### 8.3.8 字符串常量管理原则
**可能多次使用的较长字符串，需要配置为固定的宏，方便各处调用与统一，防止出现可能的前后文不匹配问题**

**缓冲区大小也应该定义为宏常量**：
```c
// ❌ 错误设计：使用魔法数字定义缓冲区大小
char timestamp[64];
char time_str[32];
char ms_part[16];

// ✅ 正确设计：使用宏定义管理缓冲区大小
#define TFW_TIMESTAMP_LEN_MAX 32        // 最大时间戳字符串长度
#define TFW_TIMESTAMP_BUFFER_SIZE 64    // 时间戳推荐缓冲区大小

char timestamp[TFW_TIMESTAMP_BUFFER_SIZE];
char time_str[TFW_TIMESTAMP_LEN_MAX];
char ms_part[16];  // 小缓冲区可以保持原样，但要有注释说明
```

```c
// ❌ 错误设计：在代码中直接使用字符串常量
g_config_manager.configs[TFW_CONFIG_MAIN_VERSION].value.string_value = TFW_Strdup("1.0.0");
g_config_manager.configs[TFW_CONFIG_LOGGING_OUTPUT].value.string_value = TFW_Strdup("console");
g_config_manager.configs[TFW_CONFIG_LOGGING_FILE_PATH].value.string_value = TFW_Strdup("./logs");

// ✅ 正确设计：使用宏定义管理字符串常量
#define TFW_VERSION_STRING "1.0.0"
#define TFW_CONFIG_DEFAULT_LOGGING_OUTPUT "console"
#define TFW_CONFIG_DEFAULT_LOGGING_FILE_PATH "./logs"

g_config_manager.configs[TFW_CONFIG_MAIN_VERSION].value.string_value = TFW_Strdup(TFW_VERSION_STRING);
g_config_manager.configs[TFW_CONFIG_LOGGING_OUTPUT].value.string_value = TFW_Strdup(TFW_CONFIG_DEFAULT_LOGGING_OUTPUT);
g_config_manager.configs[TFW_CONFIG_LOGGING_FILE_PATH].value.string_value = TFW_Strdup(TFW_CONFIG_DEFAULT_LOGGING_FILE_PATH);
```

**配置名称也应该使用宏定义**：
```c
// ❌ 错误设计：在函数中硬编码配置名称
static const char* GetKeyName(TFW_ConfigKey key) {
    switch (key) {
        case TFW_CONFIG_MAIN_VERSION:
            return "main.version";  // 硬编码字符串
        case TFW_CONFIG_LOGGING_LEVEL:
            return "logging.level"; // 硬编码字符串
        // ...
    }
}

// ✅ 正确设计：使用宏定义管理配置名称
#define TFW_CONFIG_NAME_MAIN_VERSION "main.version"
#define TFW_CONFIG_NAME_LOGGING_LEVEL "logging.level"

static const char* GetKeyName(TFW_ConfigKey key) {
    switch (key) {
        case TFW_CONFIG_MAIN_VERSION:
            return TFW_CONFIG_NAME_MAIN_VERSION;
        case TFW_CONFIG_LOGGING_LEVEL:
            return TFW_CONFIG_NAME_LOGGING_LEVEL;
        // ...
    }
}
```

**字符串常量管理原则**：
1. **版本信息**：版本号、构建号等应定义为宏常量
2. **配置名称**：配置文件中的键名应定义为宏常量
3. **默认值**：配置项的默认值应定义为宏常量
4. **路径信息**：文件路径、目录路径应定义为宏常量
5. **错误消息**：常用的错误消息应定义为宏常量
6. **格式字符串**：日志格式、输出格式应定义为宏常量

### 8.3.9 指针判断显式性要求
**指针判断必须使用显式的 NULL 比较形式，避免使用隐式的真值判断**

```c
// ❌ 错误设计：隐式指针判断，容易引起阅读错误
if (ptr) {
    // 处理非空指针
}

if (!ptr) {
    // 处理空指针
}

// ✅ 正确设计：显式指针判断，提高代码可读性
if (ptr != NULL) {
    // 处理非空指针
}

if (ptr == NULL) {
    // 处理空指针
}
```

**显式指针判断的优势**：
1. **提高可读性**：明确表达意图，避免歧义
2. **减少错误**：在复杂表达式或长变量名时，显式比较更安全
3. **便于维护**：代码意图清晰，便于后续维护和修改
4. **统一风格**：保持代码风格的一致性

**特殊情况处理**：
```c
// 对于布尔类型，可以使用隐式判断
if (is_valid) {
    // 处理有效状态
}

// 对于整数类型，可以使用隐式判断
if (count) {
    // 处理非零计数
}

// 但对于指针类型，必须使用显式判断
if (data_ptr != NULL) {
    // 处理非空指针
}
```

### 8.3.10 内存安全检查清单
在代码审查时，必须检查以下内存安全要点：

- [ ] **无指针返回**：函数不返回指向可能无效内存的指针
- [ ] **缓冲区检查**：所有缓冲区操作都有边界检查
- [ ] **参数验证**：所有指针参数都进行NULL检查
- [ ] **资源清理**：错误路径中正确清理已分配的资源
- [ ] **生命周期明确**：内存的所有权和生命周期清晰
- [ ] **无静态缓冲区**：避免使用线程不安全的静态缓冲区
- [ ] **统一错误码**：使用统一的错误码表示不同的错误情况
- [ ] **无效值处理**：对无效输入返回明确的无效值，而不是看似可用的默认值
- [ ] **字符串常量管理**：可能多次使用的字符串应定义为宏常量，避免硬编码
- [ ] **缓冲区大小管理**：常用的缓冲区大小应定义为宏常量，避免魔法数字
- [ ] **指针判断显式性**：指针判断必须使用显式的 `== NULL` 或 `!= NULL` 形式

## 9. 平台兼容性

### 9.1 默认代码为unix平台适配

#### 文件目录结构
```
utils/
├── thread/
│   ├── posix/
│   │   └── TFW_thread_impl.c    # 默认UNIX实现（Linux/macOS通用）
│   ├── win32/
│   │   └── TFW_thread_impl.c    # Windows平台特殊实现
│   └── macos/
│       └── TFW_thread_impl.c    # macOS平台特殊实现
├── timer/
│   ├── posix/
│   │   └── TFW_timer_impl.c     # 默认UNIX实现（Linux通用）
│   ├── win32/
│   │   └── TFW_timer_impl.c     # Windows平台特殊实现
│   └── macos/
│       └── TFW_timer_impl.c     # macOS平台特殊实现
├── file/
│   ├── posix/
│   │   └── TFW_file_impl.c      # 默认UNIX实现（Linux/macOS通用）
│   └── win32/
│       └── TFW_file_impl.c      # Windows平台特殊实现
└── mem/
    ├── posix/
    │   └── TFW_mem_impl.c       # 默认UNIX实现（Linux/macOS通用）
    └── win32/
        └── TFW_mem_impl.c       # Windows平台特殊实现
```

#### CMake编译控制示例
```cmake
# 设置MSVC编译器使用UTF-8编码，解决中文注释编译问题
# Set MSVC compiler to use UTF-8 encoding to resolve Chinese comment compilation issues
if(MSVC)
    add_compile_options(/utf-8)
    message(STATUS "MSVC UTF-8 encoding enabled for ${MODULE_NAME}")
endif()

# 根据平台选择平台特定实现
if(WIN32)
    # Windows平台实现
    list(APPEND UTILS_SOURCES
        thread/win32/TFW_thread_impl.c
        timer/win32/TFW_timer_impl.c
        file/win32/TFW_file_impl.c
        mem/win32/TFW_mem_impl.c
    )
elseif(APPLE)
    # macOS平台实现
    list(APPEND UTILS_SOURCES
        thread/posix/TFW_thread_impl.c
        timer/macos/TFW_timer_impl.c
        file/posix/TFW_file_impl.c
        mem/posix/TFW_mem_impl.c
    )
else()
    # Linux/Unix平台实现
    list(APPEND UTILS_SOURCES
        thread/posix/TFW_thread_impl.c
        timer/posix/TFW_timer_impl.c
        file/posix/TFW_file_impl.c
        mem/posix/TFW_mem_impl.c
    )
endif()
```

### 9.2 数据类型
```c
// 使用标准整数类型
#include <stdint.h>
uint32_t value;     // 而不是 unsigned int
int64_t timestamp;  // 而不是 long long
```

### 9.3 IDE配置
编译配置需尽量保持对IDE的兼容性，如为VSCode自动生成compile_commands.json文件

#### 头文件包含路径管理
现代CMake项目应遵循以下原则，实现类似GN构建系统的便捷包含体验：

```cmake
# 为库目标设置公开的头文件路径
add_library(tfw_core STATIC src/core.cpp)
target_include_directories(tfw_core
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/include  # 公共头文件目录，会传递给依赖者
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/src      # 私有头文件目录，不传递
)

# 在可执行文件中链接库，而不是手动添加路径
add_executable(my_app main.cpp)
target_link_libraries(my_app PRIVATE tfw_core)

# 避免使用旧式全局包含（容易冲突）
# include_directories(../include)  # ❌ 不推荐
```

#### VSCode配置最佳实践

**方法一：使用CMake Tools扩展（推荐）**
1. 安装扩展：`ms-vscode.cmake-tools`
2. 在项目根目录配置Kit（编译器）和Build Type
3. CMake Tools会自动生成`compile_commands.json`文件
4. C/C++插件自动识别路径，解决红色波浪线问题

**方法二：手动配置c_cpp_properties.json（备用）**
```json
{
    "configurations": [
        {
            "name": "Linux",
            "includePath": [
                "${workspaceFolder}/**",
                "${workspaceFolder}/interface",
                "${workspaceFolder}/core/include",
                "${workspaceFolder}/utils/include"
            ],
            "defines": [],
            "compilerPath": "/usr/bin/gcc",
            "cStandard": "c11",
            "cppStandard": "c++11",
            "intelliSenseMode": "linux-gcc-x64"
        }
    ],
    "version": 4
}
```

#### 项目结构示例
```
project/
├── CMakeLists.txt
├── compile_commands.json          # CMake Tools自动生成
├── interface/
│   ├── TFW_types.h
│   └── TFW_errorno.h
├── core/
│   ├── include/
│   │   └── TFW_core.h
│   └── src/
│       └── TFW_core.cpp
└── main.cpp
```

#### 在main.cpp中的使用
```cpp
// 正确的包含方式（无需相对路径）
#include "TFW_types.h"      // 自动搜索interface目录
#include "TFW_core.h"       // 自动搜索core/include目录

int main() {
    TFW_Result result = TFW_CoreInit();
    return 0;
}
```

#### 关键配置要点
- 使用`target_include_directories(target PUBLIC path)`设置公开头文件路径
- 通过`target_link_libraries`实现依赖传递
- 避免使用全局`include_directories`
- 优先使用CMake Tools扩展自动生成`compile_commands.json`

### 9.4 编译流程控制
编译生成的中间文件控制在独立的build目录下，最终生成的文件默认生成在out目录下，项目的主编译配置文件与入口位于根目录，并为不同的平台做一个建议的编译入口脚本

#### 目录结构规范
```
project_root/
├── CMakeLists.txt                 # 主编译配置文件
├── build/                         # 中间文件目录（可清理）
│   ├── CMakeCache.txt
│   ├── CMakeFiles/
│   ├── Makefile
│   └── compile_commands.json
├── out/                           # 最终输出目录
│   ├── bin/                       # 可执行文件
│   ├── lib/                       # 库文件
│   └── include/                   # 头文件（如需要分发）
├── build_simple.sh                # Linux/macOS编译脚本
├── build_simple.bat               # Windows编译脚本
└── build_simple.ps1               # Windows PowerShell脚本
```

#### 主CMakeLists.txt配置
```cmake
cmake_minimum_required(VERSION 3.16)
project(TFW VERSION 1.0.0 LANGUAGES C CXX)

# 设置MSVC编译器使用UTF-8编码，解决中文注释编译问题
# Set MSVC compiler to use UTF-8 encoding to resolve Chinese comment compilation issues
if(MSVC)
    add_compile_options(/utf-8)

    # 确保正确链接C++标准库
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /EHsc")

    # 设置运行时库类型
    set(CMAKE_MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")

    # 确保C++标准库正确链接
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /Zc:__cplusplus")

    message(STATUS "MSVC UTF-8 encoding enabled for ${PROJECT_NAME}")
endif()

# 设置输出目录
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/../out/bin)
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/../out/lib)
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/../out/lib)

# 设置中间文件目录
set(CMAKE_BINARY_DIR ${CMAKE_SOURCE_DIR}/build)

# 添加子目录
add_subdirectory(interface)
add_subdirectory(core)
add_subdirectory(utils)
add_subdirectory(simple)

# 生成compile_commands.json（用于IDE支持）
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
```

#### Linux/macOS编译脚本 (build_simple.sh)
```bash
#!/bin/bash

# 设置错误时退出
set -e

echo "开始构建TFW项目..."

# 创建构建目录
mkdir -p build
mkdir -p out/bin
mkdir -p out/lib

# 进入构建目录
cd build

# 配置项目
echo "配置CMake项目..."
cmake .. -DCMAKE_BUILD_TYPE=Release

# 编译项目
echo "编译项目..."
make -j$(nproc)

echo "构建完成！"
echo "可执行文件位置: ../out/bin/"
echo "库文件位置: ../out/lib/"
```

#### Windows批处理脚本 (build_simple.bat)
```batch
@echo off
setlocal enabledelayedexpansion

echo 开始构建TFW项目...

REM 创建构建目录
if not exist build mkdir build
if not exist out\bin mkdir out\bin
if not exist out\lib mkdir out\lib

REM 进入构建目录
cd build

REM 配置项目
echo 配置CMake项目...
cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release

REM 编译项目
echo 编译项目...
cmake --build . --config Release

echo 构建完成！
echo 可执行文件位置: ..\out\bin\
echo 库文件位置: ..\out\lib\

pause
```

#### Windows PowerShell脚本 (build_simple.ps1)
```powershell
# 设置错误时退出
$ErrorActionPreference = "Stop"

Write-Host "开始构建TFW项目..." -ForegroundColor Green

# 创建构建目录
if (!(Test-Path "build")) { New-Item -ItemType Directory -Path "build" }
if (!(Test-Path "out\bin")) { New-Item -ItemType Directory -Path "out\bin" }
if (!(Test-Path "out\lib")) { New-Item -ItemType Directory -Path "out\lib" }

# 进入构建目录
Set-Location build

# 配置项目
Write-Host "配置CMake项目..." -ForegroundColor Yellow
cmake .. -G "Visual Studio 16 2019" -A x64 -DCMAKE_BUILD_TYPE=Release

# 编译项目
Write-Host "编译项目..." -ForegroundColor Yellow
cmake --build . --config Release

Write-Host "构建完成！" -ForegroundColor Green
Write-Host "可执行文件位置: ..\out\bin\" -ForegroundColor Cyan
Write-Host "库文件位置: ..\out\lib\" -ForegroundColor Cyan

# 返回根目录
Set-Location ..
```

#### 清理脚本

**Linux/macOS清理脚本 (clean.sh)**
```bash
#!/bin/bash
# clean.sh - 清理构建文件

echo "清理构建文件..."

# 删除build目录
if [ -d "build" ]; then
    rm -rf build
    echo "已删除build目录"
fi

# 删除out目录
if [ -d "out" ]; then
    rm -rf out
    echo "已删除out目录"
fi

echo "清理完成！"
```

**Windows批处理清理脚本 (clean.bat)**
```batch
@echo off
echo 清理构建文件...

REM 删除build目录
if exist build (
    rmdir /s /q build
    echo 已删除build目录
)

REM 删除out目录
if exist out (
    rmdir /s /q out
    echo 已删除out目录
)

echo 清理完成！
pause
```

**Windows PowerShell清理脚本 (clean.ps1)**
```powershell
Write-Host "清理构建文件..." -ForegroundColor Yellow

# 删除build目录
if (Test-Path "build") {
    Remove-Item -Path "build" -Recurse -Force
    Write-Host "已删除build目录" -ForegroundColor Green
}

# 删除out目录
if (Test-Path "out") {
    Remove-Item -Path "out" -Recurse -Force
    Write-Host "已删除out目录" -ForegroundColor Green
}

Write-Host "清理完成！" -ForegroundColor Green
```

#### 关键配置要点
- **输出目录分离**：中间文件在`build/`，最终文件在`out/`
- **平台特定脚本**：为不同平台提供便捷的编译入口
- **CMake配置**：主配置文件位于根目录，统一管理所有模块
- **IDE支持**：自动生成`compile_commands.json`文件
- **清理机制**：提供清理脚本，便于重新构建

## 10. 代码审查检查点

### 10.1 命名规范检查
- [ ] C接口函数是否使用 `TFW_函数名（大驼峰）` 格式
- [ ] C++类方法是否使用 `PascalCase` 格式
- [ ] 内部函数是否使用 `PascalCase` 格式
- [ ] 变量是否使用 `camelCase` 格式
- [ ] 全局/静态变量是否使用 `g_变量名` 或 `s_变量名` 格式
- [ ] 宏定义是否使用 `TFW_模块_功能_具体名称` 格式
- [ ] 枚举常量是否使用 `TFW_枚举类型_具体值` 格式

### 10.2 代码格式检查
- [ ] 是否使用4个空格缩进（不使用Tab）
- [ ] 大括号是否使用K&R风格（首大括号与入口在同一行）
- [ ] 行长度是否控制在120字符以内
- [ ] 运算符前后是否添加空格
- [ ] 逗号后是否添加空格
- [ ] 换行时是否保持适当缩进和对齐

### 10.3 注释规范检查
- [ ] 文件头是否有完整的Doxygen注释（@file, @brief, @author, @date, @version）
- [ ] 函数是否有详细的参数说明（@param[in/out], @return, @retval）
- [ ] 复杂逻辑前是否有解释注释
- [ ] 行内注释是否简洁明了
- [ ] 是否有@note和@warning等特殊说明

### 10.4 错误处理检查
- [ ] 是否总是检查函数返回值
- [ ] 是否使用统一的错误码（TFW_ERROR_*）
- [ ] 错误路径中是否正确清理资源
- [ ] 是否避免使用魔法数字（-1, 0xFFFF等）
- [ ] 错误传播是否正确

### 10.5 资源管理检查
- [ ] 动态分配的内存是否及时释放
- [ ] 文件句柄是否正确关闭
- [ ] 锁是否在正确位置释放
- [ ] 是否避免野指针（释放后置nullptr）
- [ ] 是否优先使用栈上分配

### 10.6 平台兼容性检查
- [ ] 默认代码是否为UNIX平台适配
- [ ] 平台特定实现是否放在对应目录（posix/, win32/, macos/）
- [ ] 条件编译是否正确（#ifdef _WIN32, #ifdef __APPLE__）
- [ ] CMake是否根据平台选择正确的源文件
- [ ] 是否包含必要的平台特定头文件

### 10.7 性能和安全检查
- [ ] 是否避免不必要的字符串操作
- [ ] 是否使用常量字符串而非重复格式化
- [ ] 线程安全性是否考虑
- [ ] 边界条件是否正确处理
- [ ] 空指针是否检查

### 10.8 内存安全检查
- [ ] 函数是否避免返回指向可能无效内存的指针
- [ ] 所有字符串处理函数是否使用入参出参模式
- [ ] 缓冲区操作是否进行边界检查
- [ ] 所有指针参数是否进行NULL检查
- [ ] 错误路径中是否正确清理已分配的资源
- [ ] 内存的所有权和生命周期是否明确
- [ ] 是否避免使用线程不安全的静态缓冲区
- [ ] 是否使用统一的错误码表示不同错误情况
- [ ] 对无效输入是否返回明确的无效值，而不是看似可用的默认值
- [ ] 可能多次使用的字符串是否定义为宏常量，避免硬编码
- [ ] 常用的缓冲区大小是否定义为宏常量，避免魔法数字
- [ ] 指针判断是否使用显式的 `== NULL` 或 `!= NULL` 形式，避免隐式真值判断

### 10.9 日志使用检查
- [ ] 是否选择合适的日志等级
- [ ] 日志消息是否包含足够的上下文信息
- [ ] 是否使用模块专用的日志宏（TFW_LOGI_CORE等）
- [ ] 错误日志是否包含错误码和描述

### 10.10 头文件包含检查
- [ ] 是否仅包含文件名（不包含相对路径）
- [ ] 是否通过CMake配置实现头文件路径管理
- [ ] 是否使用`target_include_directories`设置公开头文件路径
- [ ] 是否通过`target_link_libraries`实现依赖传递
- [ ] 是否避免使用全局`include_directories`

### 10.11 IDE兼容性检查
- [ ] 是否生成`compile_commands.json`文件
- [ ] VSCode配置是否正确（CMake Tools或手动配置）
- [ ] 头文件智能提示是否正常工作
- [ ] 是否避免使用相对路径包含头文件
- [ ] 项目结构是否符合现代CMake最佳实践

### 10.12 平台适配检查
- [ ] 默认代码是否为UNIX平台适配
- [ ] 平台特定实现是否放在对应目录（posix/, win32/, macos/）
- [ ] 条件编译是否正确（#ifdef _WIN32, #ifdef __APPLE__）
- [ ] CMake是否根据平台选择正确的源文件
- [ ] 是否包含必要的平台特定头文件
- [ ] 平台特定代码是否与默认实现保持接口一致

---

## 11. 代码审查流程与范围

### 11.1 审查范围
代码审查应覆盖以下所有方面：
- **代码质量**：命名规范、格式一致性、注释完整性
- **功能正确性**：逻辑正确性、边界条件处理、错误处理
- **安全性**：资源管理、空指针检查、线程安全
- **性能**：算法效率、内存使用、字符串操作
- **可维护性**：代码结构、模块化设计、依赖管理
- **兼容性**：跨平台支持、编译器兼容、IDE支持

### 11.2 审查流程
1. **提交前自检**：开发者使用检查点进行自我审查
2. **同行评审**：至少一名团队成员进行代码审查
3. **自动化检查**：使用工具检查格式、命名等基础规范
4. **集成测试**：确保修改不影响现有功能
5. **最终审核**：项目负责人或技术负责人进行最终确认

### 11.3 审查工具推荐
- **代码格式检查**：clang-format, clang-tidy
- **静态分析**：Cppcheck, SonarQube
- **构建验证**：CMake, Ninja
- **IDE集成**：VSCode + CMake Tools, CLion

### 11.4 审查重点
- **新增功能**：重点关注接口设计、错误处理、资源管理
- **重构代码**：确保不破坏现有功能和接口
- **平台适配**：验证跨平台兼容性和平台特定实现
- **性能优化**：确保优化不引入新的问题
- **安全修复**：验证修复的完整性和影响范围

---

本规范将随着项目发展持续更新和完善。
