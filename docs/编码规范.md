# TemplateFrameWork (TFW) 编码规范

## 1. 总体原则

### 1.1 代码质量要求
- 代码应该简洁、清晰、可维护
- 优先考虑代码的可读性和可理解性
- 遵循一致的命名约定和格式规范
- 适当添加注释，特别是复杂逻辑部分

### 1.2 兼容性要求
- C接口必须完全兼容C89/C99标准
- C++代码建议使用C++11及以上标准
- 跨平台兼容（Windows、Linux、macOS）
- 支持多种编译器（GCC、Clang、MSVC）

## 2. 命名规范

### 2.1 文件命名
- 头文件：`TFW_模块名.h`
- 源文件：`TFW_模块名.c` 或 `TFW_模块名.cpp`
- 示例：`TFW_core.h`、`TFW_core.cpp`

### 2.2 函数命名

#### C接口函数
```c
// 格式：TFW_模块名_功能描述（全大写，下划线分隔）
TFW_Result TFW_CORE_INITIALIZE();
TFW_Result TFW_CORE_EXIT();
TFW_Result TFW_UTILS_LOG_INIT();
```

#### C++类方法
```cpp
// 格式：PascalCase（首字母大写的驼峰命名）
class CoreInterface {
public:
    static CoreInterface* GetInstance();
    TFW_Result Initialize();
    TFW_Result ExecuteOperation(const std::string& operation);
};
```

#### 内部函数
```c
// 格式：snake_case（小写字母，下划线分隔）
static int format_log_message(char* buffer, size_t size, const char* format, ...);
static void cleanup_resources();
```

### 2.3 变量命名

#### 全局变量/静态变量
```c
// 格式：g_变量名 或 s_变量名
static bool g_is_initialized = false;
static CoreInterface* s_instance = nullptr;
```

#### 局部变量
```c
// 格式：snake_case
int error_code = 0;
char* buffer_ptr = nullptr;
size_t buffer_size = 1024;
```

#### 成员变量
```cpp
// 格式：变量名_ （下划线后缀）
class Core {
private:
    bool is_initialized_;
    TFW_Type main_type_;
    std::string operation_name_;
};
```

### 2.4 常量和宏命名

#### 宏定义
```c
// 格式：TFW_模块_功能_具体名称（全大写，下划线分隔）
#define TFW_LOG_BUFFER_SIZE 1024
#define TFW_CORE_MAX_RETRY_COUNT 3
#define TFW_UTILS_VERSION_MAJOR 1
```

#### 枚举常量
```c
// 格式：TFW_枚举类型_具体值
typedef enum {
    TFW_LOG_LEVEL_TRACE = 0,
    TFW_LOG_LEVEL_DEBUG = 1,
    TFW_LOG_LEVEL_INFO = 2,
    TFW_LOG_LEVEL_WARNING = 3,
    TFW_LOG_LEVEL_ERROR = 4,
    TFW_LOG_LEVEL_FATAL = 5
} TFW_LogLevel;
```

### 2.5 类型定义
```c
// 格式：TFW_类型名
typedef enum TFW_ErrorCode TFW_ErrorCode;
typedef int32_t TFW_Result;
typedef struct TFW_LogContext TFW_LogContext;
```

## 3. 代码格式

### 3.1 缩进和空格
- 使用4个空格进行缩进，不使用Tab
- 运算符前后添加空格
- 逗号后添加空格
- 函数调用的括号内侧不加空格

```c
// 正确示例
int result = calculate_value(param1, param2, param3);
if (result > 0) {
    process_result(result);
}

// 错误示例
int result=calculate_value( param1,param2,param3 );
if(result>0){
process_result(result);
}
```

### 3.2 大括号风格
- 使用Allman风格（大括号独占一行）
- 即使只有一行代码，也要使用大括号

```c
// 正确示例
if (condition)
{
    do_something();
}
else
{
    do_something_else();
}

// 函数定义
int function_name(int param)
{
    return param * 2;
}
```

### 3.3 行长度
- 每行代码不超过100个字符
- 长的函数调用或表达式需要换行
- 换行时注意对齐

```c
// 长函数调用换行示例
result = very_long_function_name(parameter1, parameter2, 
                                parameter3, parameter4,
                                parameter5);

// 长条件表达式换行示例
if (very_long_condition_check() && 
    another_long_condition_check() &&
    third_condition_check())
{
    // 处理逻辑
}
```

## 4. 注释规范

### 4.1 文件头注释
```c
/**
 * @file TFW_core.h
 * @brief TFW框架核心模块定义
 * @author 开发者姓名
 * @date 创建日期
 * @version 1.0.0
 * 
 * 详细描述文件的功能和用途
 */
```

### 4.2 函数注释
```c
/**
 * @brief 初始化核心模块
 * @param[in] config 配置参数指针，可以为NULL使用默认配置
 * @param[out] handle 返回的句柄指针
 * @return TFW_Result 返回操作结果
 * @retval TFW_SUCCESS 初始化成功
 * @retval TFW_ERROR_INVALID_PARAM 参数无效
 * @retval TFW_ERROR_ALREADY_INITIALIZED 已经初始化
 * 
 * @note 该函数只能调用一次，重复调用将返回错误
 * @warning 在多线程环境中使用时需要外部同步
 */
TFW_Result TFW_CORE_INITIALIZE(const TFW_Config* config, TFW_Handle* handle);
```

### 4.3 行内注释
```c
int buffer_size = 1024;     // 缓冲区大小，足够存储日志消息
bool is_valid = false;      // 标记数据是否有效

// 复杂逻辑前的解释注释
// 这里使用双重检查锁定模式确保线程安全的单例初始化
if (instance == nullptr)
{
    lock_mutex();
    if (instance == nullptr)
    {
        instance = create_instance();
    }
    unlock_mutex();
}
```

## 5. 错误处理

### 5.1 返回值检查
```c
// 总是检查函数返回值
TFW_Result result = TFW_CORE_INITIALIZE();
if (result != TFW_SUCCESS)
{
    TFW_LOGE_CORE("初始化失败: %d", result);
    return result;
}
```

### 5.2 错误码使用
```c
// 使用统一的错误码
return TFW_ERROR_INVALID_PARAM;  // 而不是返回 -1 或其他魔法数字

// 错误传播
TFW_Result internal_result = internal_function();
if (internal_result != TFW_SUCCESS)
{
    return internal_result;  // 直接传播错误码
}
```

### 5.3 资源清理
```c
// 总是在错误路径中清理资源
char* buffer = malloc(size);
if (buffer == nullptr)
{
    return TFW_ERROR_MEMORY_ALLOCATION;
}

FILE* file = fopen(filename, "r");
if (file == nullptr)
{
    free(buffer);  // 清理已分配的资源
    return TFW_ERROR_FILE_OPEN;
}

// ... 使用资源 ...

// 正常路径清理
fclose(file);
free(buffer);
return TFW_SUCCESS;
```

## 6. 头文件规范

### 6.1 头文件保护
```c
#ifndef TFW_CORE_H
#define TFW_CORE_H

// 头文件内容

#endif // TFW_CORE_H
```

### 6.2 包含顺序
```c
// 1. 系统头文件
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 2. 第三方库头文件
#include <third_party_lib.h>

// 3. 项目头文件
#include "TFW_types.h"
#include "TFW_errorno.h"
```

### 6.3 C++兼容性
```c
#ifdef __cplusplus
extern "C" {
#endif

// C接口声明

#ifdef __cplusplus
}
#endif
```

## 7. 日志使用规范

### 7.1 日志等级选择
```c
TFW_LOGT_CORE("详细的调试追踪信息");           // 仅用于开发调试
TFW_LOGD_CORE("调试信息: 变量值 = %d", value);  // 开发和测试阶段
TFW_LOGI_CORE("操作完成: %s", operation);        // 重要的状态信息
TFW_LOGW_CORE("警告: 参数可能不合理 = %d", param); // 可能的问题
TFW_LOGE_CORE("错误: 操作失败 = %d", error_code);  // 错误信息
TFW_LOGF_CORE("致命错误: 系统无法继续运行");      // 系统级错误
```

### 7.2 日志格式
```c
// 包含足够的上下文信息
TFW_LOGI_CORE("用户登录成功: user_id=%d, session_id=%s", 
              user_id, session_id);

// 错误日志包含错误码和描述
TFW_LOGE_CORE("文件操作失败: file=%s, error=%d, message=%s", 
              filename, errno, strerror(errno));
```

## 8. 性能考虑

### 8.1 避免不必要的字符串操作
```c
// 推荐：使用常量字符串
const char* get_status_string(int status)
{
    switch (status)
    {
        case 0: return "Success";
        case 1: return "Error";
        default: return "Unknown";
    }
}

// 避免：每次都重新格式化字符串
```

### 8.2 内存管理
```c
// 尽量使用栈上分配
char buffer[256];  // 而不是 malloc/free

// 需要动态分配时，及时释放
char* buffer = malloc(size);
if (buffer != nullptr)
{
    // 使用buffer
    free(buffer);
    buffer = nullptr;  // 避免野指针
}
```

## 9. 平台兼容性

### 9.1 条件编译
```c
#ifdef _WIN32
    #include <windows.h>
    #define TFW_THREAD_ID GetCurrentThreadId()
#else
    #include <pthread.h>
    #include <unistd.h>
    #define TFW_THREAD_ID pthread_self()
#endif
```

### 9.2 数据类型
```c
// 使用标准整数类型
#include <stdint.h>
uint32_t value;     // 而不是 unsigned int
int64_t timestamp;  // 而不是 long long
```

## 10. 代码审查检查点

### 10.1 基本检查
- [ ] 命名是否符合规范
- [ ] 格式是否一致
- [ ] 是否有足够的注释
- [ ] 错误处理是否完整
- [ ] 资源是否正确释放

### 10.2 逻辑检查
- [ ] 边界条件是否处理
- [ ] 空指针是否检查
- [ ] 线程安全性是否考虑
- [ ] 性能是否合理

### 10.3 兼容性检查
- [ ] C/C++兼容性
- [ ] 跨平台兼容性
- [ ] 编译器兼容性

---

本规范将随着项目发展持续更新和完善。